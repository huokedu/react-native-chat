/*
* (The MIT License)
* Copyright (c) 2015-2016 YunJiang.Fang <42550564@qq.com>
*/
'use strict';

var Sqlite = require('@remobile/react-native-sqlite');
var fs = require('react-native-fs');
var FileTransfer = require('@remobile/react-native-file-transfer');
var md5 = require("./md5.js");

const DB_NAME = "cache_image";
const TABLE_CACHE_ID = "cache_id";
const TABLE_CACHE_IMAGE = "cache_image";
const TABLE_CACHE_STORAGE = "cache_storage";
const CACHE_IMAGE_DIR = 'cacheImages';
const CACHE_IMAGE_SIZE = 1024*1024*50;

var syncImageSource = {};
var db = Sqlite.openDatabase({name:DB_NAME, location: 'default'});

class StorageMgr {
    constructor() {
        var self = this;
        self.storage = 0;
        fs.mkdir(fs.DocumentDirectoryPath+'/'+CACHE_IMAGE_DIR);
        //console.log(fs.DocumentDirectoryPath+'/'+CACHE_IMAGE_DIR);
        db.transaction((tx)=>{
            tx.executeSql('CREATE TABLE IF NOT EXISTS '+TABLE_CACHE_IMAGE+' (url varchar(40) primary key, ref integer, size integer, time integer)');
            tx.executeSql('CREATE TABLE IF NOT EXISTS '+TABLE_CACHE_ID+' (id varchar(40) primary key, url varchar(40))');
            tx.executeSql('CREATE TABLE IF NOT EXISTS '+TABLE_CACHE_STORAGE+' (key integer primary key, storage integer)');
            tx.executeSql('SELECT storage FROM '+TABLE_CACHE_STORAGE+' WHERE key=1', [], (tx, rs)=>{
                if (rs.rows.length) {
                    self.storage = rs.rows.item(0).storage;
                    //console.log('StorageMgr', self.storage);
                }
            });
        }, (error)=>{
            //console.log('StorageMgr <error>', error);
        });
    }
    getCacheFilePath(filename) {
        return fs.DocumentDirectoryPath+'/'+CACHE_IMAGE_DIR+'/'+filename;
    }
    lock(filename) {
        syncImageSource[filename] = true;
    }
    unlock(filename) {
        delete syncImageSource[filename];
    }
    islock(filename) {
        return syncImageSource[filename];
    }
    updateStorage(offset) {
        var self = this;
        //console.log('StorageMgr updateStorage', self.storage, offset);
        return new Promise(async(resolve, reject) => {
            db.transaction((tx)=>{
                tx.executeSql('UPDATE '+TABLE_CACHE_STORAGE+' SET storage=storage+?'+' WHERE key=1', [offset], (tx, rs)=>{
                    if (rs.rowsAffected == 0) {
                        tx.executeSql('INSERT INTO '+TABLE_CACHE_STORAGE+' (key, storage) VALUES (1, ?)', [offset], (tx, rs)=>{
                            //console.log('updateStorage <insert>', offset);
                            self.storage = offset;
                            resolve(true);
                        });
                    } else {
                        //console.log('updateStorage <update>', offset);
                        self.storage += offset;
                        resolve(true);
                    }
                });
            }, (error)=>{
                //console.log('updateStorage <error>', error);
                resolve(false);
            });
        });
    }
    clear() {
        var self = this;
        fs.unlink(fs.DocumentDirectoryPath+'/'+CACHE_IMAGE_DIR);
        db.transaction((tx)=>{
            tx.executeSql('DROP TABLE '+TABLE_CACHE_ID);
            tx.executeSql('DROP TABLE '+TABLE_CACHE_IMAGE);
            tx.executeSql('DROP TABLE '+TABLE_CACHE_STORAGE);
            self.storage = 0;
            fs.mkdir(fs.DocumentDirectoryPath+'/'+CACHE_IMAGE_DIR);
            //console.log(fs.DocumentDirectoryPath+'/'+CACHE_IMAGE_DIR);
            db.transaction((tx)=>{
                tx.executeSql('CREATE TABLE IF NOT EXISTS '+TABLE_CACHE_IMAGE+' (url varchar(40) primary key, ref integer, size integer, time integer)');
                tx.executeSql('CREATE TABLE IF NOT EXISTS '+TABLE_CACHE_ID+' (id integer primary key, url varchar(40))');
                tx.executeSql('CREATE TABLE IF NOT EXISTS '+TABLE_CACHE_STORAGE+' (key integer primary key, storage integer)');
                tx.executeSql('SELECT storage FROM '+TABLE_CACHE_STORAGE+' WHERE key=1', [], (tx, rs)=>{
                    if (rs.rows.length) {
                        self.storage = rs.rows.item(0).storage;
                        //console.log('StorageMgr', self.storage);
                    }
                });
            }, (error)=>{
                //console.log('StorageMgr <error>', error);
            });
        });
    }
    addImageRef(url, size) {
        return new Promise((resolve, reject) => {
            db.transaction((tx)=>{
                var ref = size?'1':'ref+1';
                tx.executeSql('UPDATE '+TABLE_CACHE_IMAGE+' SET ref='+ref+' WHERE url=?', [url], (tx, rs)=>{
                    if (rs.rowsAffected == 0) {
                        tx.executeSql('INSERT INTO '+TABLE_CACHE_IMAGE+' (url, ref, size, time) VALUES (?, ?, ?, ?)', [url, 1, size, parseInt(Date.now()/1000)], (tx, rs)=>{
                            //console.log('subImageRef <insert>', url, size);
                            resolve(true);
                        });
                    } else {
                        //console.log('subImageRef <undo>', url, size);
                        resolve(true);
                    }
                });
            }, (error)=>{
                //console.log('subImageRef <error>', url, size, error);
                resolve(false);
            });
        });
    }
    subImageRef(url) {
        var self = this;
        return new Promise((resolve, reject) => {
            db.transaction((tx)=>{
                tx.executeSql('SELECT ref,size FROM '+TABLE_CACHE_IMAGE+' WHERE url=?', [url], (tx, rs)=>{
                    var item = rs.rows.item(0);
                    var ref = item.ref;
                    var size = item.size;
                    if (ref == 1) {
                        tx.executeSql('DELETE FROM '+TABLE_CACHE_IMAGE+' WHERE url=?', [url], async(tx, rs)=>{
                            await fs.unlink(self.getCacheFilePath(url));
                            await self.updateStorage(-size);
                            //console.log('subImageRef <delete>', url);
                            resolve(true);
                        });
                    } else {
                        tx.executeSql('UPDATE '+TABLE_CACHE_IMAGE+' SET ref=ref-1 WHERE url=?', [url], (tx, rs)=>{
                            //console.log('subImageRef <update>', url);
                            resolve(true);
                        });
                    }
                });
            }, (error)=>{
                //console.log('subImageRef <error>', url, error);
                resolve(false);
            });
        });
    }
    checkCacheId(id, url, size) {
        var self = this;
        return new Promise((resolve, reject) => {
            db.transaction((tx)=>{
                tx.executeSql('SELECT url FROM '+TABLE_CACHE_ID+' WHERE id=?', [id],  (tx, rs)=>{
                    if (rs.rows.length) {
                        var item = rs.rows.item(0);
                        var oldurl = item.url;
                        if (url !== oldurl) {
                            tx.executeSql('UPDATE '+TABLE_CACHE_ID+' SET url=? WHERE id=?', [url, id],  async(tx, rs)=>{
                                //console.log('checkCacheId <update oldurl>', id, url, size, oldurl);
                                await self.addImageRef(url, size);
                                await self.subImageRef(oldurl);
                                self.unlock(url);
                                resolve(true);
                            });
                        } else {
                            self.unlock(url);
                            resolve(true);
                        }
                    } else {
                        tx.executeSql('INSERT INTO '+TABLE_CACHE_ID+' (id, url) VALUES (?, ?)', [id, url], async(tx, rs)=>{
                            //console.log('checkCacheId <insert new url>', id, url, size);
                            await self.addImageRef(url, size);
                            self.unlock(url);
                            resolve(true);
                        });
                    }
                });
            }, (error)=>{
                resolve(false);
                //console.log('checkCacheId <error>', id, url, size, error);
                self.unlock(url);
            });
        });
    }
    deleteCacheImage(storage) {
        var self = this;
        return new Promise((resolve, reject) => {
            db.transaction((tx)=>{
                tx.executeSql('SELECT url,size FROM '+TABLE_CACHE_IMAGE+' WHERE time=(SELECT MIN(time) FROM '+TABLE_CACHE_IMAGE+')', [], (tx, rs)=>{
                    if (rs.rows.length) {
                        var item = rs.rows.item(0);
                        var url = item.url;
                        var size = item.size;
                        tx.executeSql('DELETE FROM '+TABLE_CACHE_IMAGE+' WHERE url=?', [url], (tx, rs)=>{
                            tx.executeSql('DELETE FROM '+TABLE_CACHE_ID+' WHERE url=?', [url], async(tx, rs)=>{
                                //console.log('deleteCacheImage <delete>', url, size);
                                storage -= size;
                                await fs.unlink(self.getCacheFilePath(url));
                                await self.updateStorage(-size);
                                resolve(storage);
                            });
                        });
                    }
                });
            }, (error)=>{
                //console.log('deleteCacheImage <error>', error);
                reject(error);
            });
        });
    }
    checkCacheStorage(size) {
        var self = this;
        return new Promise(async(resolve, reject) => {
            var storage = self.storage + size;
            //console.log('target:', storage);
            while (storage >= CACHE_IMAGE_SIZE) {
                storage = await self.deleteCacheImage(storage);
                //console.log('after:', storage);
            }
            resolve();
        });
    }
    downloadImage(url, filepath, cacheId, filename) {
        var self = this;
        return new Promise(async(resolve, reject) => {
            var fileTransfer = new FileTransfer();
            fileTransfer.download(
                url,
                filepath,
                async(result)=>{
                    resolve(true);
                    console.log("downloadImage success:", result);
                    var info = await fs.stat(filepath);
                    var bytesWritten = info.size;
                    await self.checkCacheId(cacheId, filename, bytesWritten);
                    await self.updateStorage(bytesWritten);
                    await self.checkCacheStorage(bytesWritten);
                },
                (error)=>{
                    console.log("downloadImage error:", error);
                    resolve(false);
                    self.unlock(filename);
                },
                true
            );
        });
    }
    syncCheckImageSource(obj) {
        var self = this;
        if (self.islock(obj.filename)) {
            setTimeout(()=>{self.syncCheckImageSource(obj)}, 100);
        } else {
            self.doCheckImageSource(obj);
        }
    }
    async doCheckImageSource(obj) {
        var {cacheId, url, filename, filepath, resolve} = obj;
        this.lock(filename);
        var isExist = await fs.exists(filepath);
        //console.log(this.param);
        console.log('Is File exist', isExist);
        if (isExist) {
            resolve({uri:'file://'+filepath});
            //console.log(this.state);
            this.checkCacheId(cacheId, filename);
        } else {
            var success = await this.downloadImage(url, filepath, cacheId, filename);
            resolve(success ? {uri:'file://'+filepath} : null);
        }
    }
    checkImageSource(cacheId, url) {
        var self = this;
        return new Promise(async(resolve, reject) => {
            var type = url.replace(/.*\.(.*)/, '$1');
            var filename =  md5(url)+'.'+type;
            var filepath = self.getCacheFilePath(filename);
            self.syncCheckImageSource({cacheId, url, filename, filepath, resolve});
        });
    }
}

module.exports = StorageMgr;
